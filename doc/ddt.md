

# DDT - Dynamic Debugging for Tcl

This package provides dynamic debugging support for Tcl 8.5 or higher. It
provides mainly commands to run Tcl files or scripts and to step through them,
to define breakpoints, and to access variables in the context of the debugged
code.

DDT instrumentalizes the debugged code by inserting debugging helper
commands. This is transparent (=invisible) to the user except he checks the
procedure bodies for example with 'info body'. DDT uses the "unsupported"
disassemble function of Tcl 8.5 and 8.6 to analyse the code to debug, to
identify potential program execution stop locations.

# Dynamic Debugging for Tcl

## API

DDT exposes the following API commands.

***
### Proc: ddt::Configure

Configure DDT, or return the current configuration. If no argument is
provided the current configuration is returned. If a single argument
referring a configuration parameter is provided the configuration for
this parameter is returned. Pairs of parameter names and values need
to be provided if a new configuration needs to be defined. The
available configurations are described in section [Configuration].

##### Parameters

|Parameters|Description
|--:|---
|[args]|Configuration definition list

##### Returns

Returns the configuration if no new configuration is defined

##### Examples

```
 ddt::Configure -BreakCallback DebugGuiUpdate
 ddt::Configure -InitVars {argv0 {} argv {}} -InitScript "package require Tk"
 ddt::Configure -Mode disable
```

##### See also

[Configuration]

***
### Proc: ddt::Run

Starts the execution of a file or of a script. If breakpoints are
defined the debug environment is initialized. If the configuration
*-SI* is set the file or script is executed by a slave interpreter that
is created.

The two arguments allow using this command in 2 ways.

* A file is provided but not a script: The file is executed.
* A file and a script is provided. The script is executed. The file

name is just used as identifier.

##### Parameters

|Parameters|Description
|--:|---
|FileName|File name (can also be a fictitious identifier)
|[Script]|If provided this script will be executed

##### Returns

Result returned by the file/script

##### See Also

[ddt::Cont], [ddt::Step], [ddt::Stop], [ddt::SetBP]

***
### Proc: ddt::Cont

Continues the execution of the program that is stopped on a breakpoint.

##### Returns

Returns always the execution state 'cont'.

##### See Also

[ddt::Run], [ddt::Step], [ddt::Stop], [ddt::SetBP]

***
### Proc: ddt::Step

Performs a single step in a program that is stopped on a breakpoint.

##### Returns

Returns always the execution state 'step'.

##### See Also

[ddt::Run], [ddt::Cont], [ddt::Stop], [ddt::SetBP]

***
### Proc: ddt::Refresh

Forces the callback function to be re-executed. A refresh of the
application UI's status can be forced in this way.

##### Returns

Returns always the execution state 'refresh'.

***
### Proc: ddt::Stop

Stops the execution of a program that is currently either running or
stopped on a breakpoint.

##### Returns

Returns always the execution state 'stop'.

##### See Also

[ddt::Run], [ddt::Cont], [ddt::Step], [ddt::SetBP]

***
### Proc: ddt::Eval

Evaluates a command sequence in the context of the executed procedure
of  the debugged program. Returns the result of the command sequence.
This command can be used by the callback function to inspect the status
of the debugged program or procedure. However, this command cannot be
used by functions that are interactively executed (e.g. via buttons).

##### Parameters

|Parameters|Description
|--:|---
|args|Command sequence

##### Returns

Result returned by the command sequence, or any error generated by it

##### See Also

[ddt::Exec]

***
### Proc: ddt::Exec

Evaluates a command sequence in the context of the executed procedure
of  the debugged program. Returns always an empty string.
This command can be used by the callback function as well as by a
function that is interactively executed (e.g. via buttons).

##### Parameters

|Parameters|Description
|--:|---
|args|Command sequence

##### Returns

\-

##### See Also

[ddt::Eval]

***
### Proc: ddt::SetBP

Set or delete a breakpoint in a specified file at a specified line. If
no condition is explicitly specified, or if the condition is 1, a non
conditional breakpoint is defined. If the condition is 0 or '' an
eventually defined breakpoint is deleted. The provided condition will
be used in all other cases as a dynamic breakpoint condition.

##### Parameters

|Parameters|Description
|--:|---
|FileName|File to apply the breakpoint definitions
|LineNbr| Line to which the breakpoint definition
|[Condition]|Optional condition

##### Returns

Returns the new breakpoint condition

##### See Also

[ddt::GetBP], [ddt::SwapBP]

***
### Proc: ddt::GetBP

Returns for a specified file the breakpoint definitions. If no line is
specified GetBP returns for all breakpoint for the file, otherwise only
the ones for the specified line. The returned breakpoint definitions
is a list composed by pairs of line numbers and breakpoint conditions.

##### Parameters

|Parameters|Description
|--:|---
|FileName| File for which the breakpoint definitions have to be returned
|[LineNbr]|If defined only the breakpoint definitions are returned only for this line

##### Returns

Breakpoint definition list

##### See Also

[ddt::SetBP], [ddt::SwapBP]

***
### Proc: ddt::SwapBP

Swaps a breakpoint in a specified line of a specified file. If no
breakpoint (conditional or non conditional) exists, a non conditional
breakpoint will be created. Otherwise the existing breakpoint will be
deleted.

##### Parameters

|Parameters|Description
|--:|---
|FileName|File for which the breakpoint definitions needs to be applied
|LineNbr| Line for which the breakpoint definition needs to be applied

##### Returns

Returns the new breakpoint condition

##### See Also

[dt::GetBP], [dt::SetBP]

***
### Proc: ddt::GetBPLocations

Returns for a specified file the possible breakpoint locations. If a
line is specified GetBPLocations returns the breakpoint locations just
for this line.

##### Parameters

|Parameters|Description
|--:|---
|FileName| File for which the breakpoint locations have to be returned
|[LineNbr]|If defined: Line for which the breakpoint locations have to be returned

##### Returns

Breakpoint location list

***
### Proc: ddt::GetExecState

Returns the execution state of the currently debugged file or script.

##### The following states exist

* "" (initialization state)
* cont (continuous running)
* step (single instruction execution)
* stop (stop request)
* refresh (refresh request),
* exec (command sequence execution request)
* stopped (state while the Brk instruction is executed)

##### Returns

Returns the current execution state.

## Configuration

DDT is configured via the [ddt::Configure] command. The configuration is
stored by DDT inside the *Config* array variable. DDT uses the following
configurations:

## DDT internal variables

Here is some information about the internal variables.
The following array variables contain information about the
instrumentalized source scripts and files. All of them are using the
source identifier as array index.

||Description
|--:|---
|DisassembleInfo |Disassemble information of the source
|SourceScript    |Source script
|SourceIScript   |Instrumentalized source script
|CommandPosListN |List of character positions that correspond to a command begin
|CommandPosListRC|List of line/column positions that correspond to a command begin

Registered source files and breakpoints.

||Description
|--:|---
|SourceFiles|Source file name list
|BP         |Breakpoint array

The following variables contain information about the execution state of
the program being debugged.

||Description
|--:|---
|ExecSourceId|Source identifier
|ExecLineNbr|Currently executed line number
|ExecState|Execution state (see \<ddt::GetExecState>)

## DDT internal commands

Internal commands used by DDT.

***
### Proc: ddt::Init

Initializes, or re-initializes all variables used internally by DDT.
The source file list and the defined breakpoints will be kept unless
a full initialization is performed.

##### Parameters

|Parameters|Description
|--:|---
|[FullInit]|A full initialization will be performed if set to 1

##### Returns

\-

##### See Also

[DDT internal variables]

***
### Proc: ddt::GetSourceId

Returns the source identifier for a file. The source identifier is an
integer.

##### Parameters

|Parameters|Description
|--:|---
|FileName|File name (can also be a fictitious identifier)

##### Returns

Source identifier

##### See Also

[ddt::GetSource]

***
### Proc: ddt::GetSource

Returns the source (e.g. script) designated by the file name.

##### Parameters

|Parameters|Description
|--:|---
|FileName|File name (can also be a fictitious identifier)

##### Returns

Source script

##### See Also

[ddt::GetSourceId]

***
### Proc: ddt::GetInstrumentalizedSource

Get the instrumentalized source script of a file or of a script. This
command can be used in 2 ways.

* Just a file is provided but not a script: In this case the file

content is read, instrumentalized and returned.

* A file and a script is provided. The provided script is

instrumentalized and returned in this case. The file name is used as
identifier to cache instrumentalized source script.

##### Parameters

|Parameters|Description
|--:|---
|FileName|File name (can also be a fictitious identifier)
|[Script]|If provided this script will be instrumentalized

##### Returns

Instrumentalized source script

##### See Also

[ddt::Run], [ddt::Instrumentalize], [ddt::GetSourceId],  [ddt::GetSource]

***
### Proc: ddt::source_debug

Tcl source command patch. This command instrumentalizes the sourced
files and execute them then in debug mode if the following conditions

##### are satisfied

* Currently executed code is part of the debugged program (not part of

the debug environment)

* Sourced file is not sourced from a package
* The source command is not called with the -encoding option
* The sourced file is not pkgIndex.tcl

If one of these conditions is not satisfied, source_debug will source
the file via the normal source command.

##### Parameters

|Parameters|Description
|--:|---
|args|Arguments normally provided to *source*

##### Returns

Return value normally provided by *source*

##### See Also

[ddt::package_debug], [ddt::info_debug]

***
### Proc: ddt::package_debug

Tcl package command patch. This command keeps track about packages that
are going to be loaded. This information is used by the patched source
command ([ddt::source_debug]) to disable the instrumentalization of
sourced files if they are sourced by the package command.

##### Parameters

|Parameters|Description
|--:|---
|args|Arguments of the *package* command

##### Returns

Return value of the *package* command

##### See Also

[ddt::source_debug], [ddt::info_debug]

***
### Proc: ddt::info_debug

Patches the info command. The 'info script' command doesn't work for
scripts that are sourced in debug mode (e.g. executed as
instrumentalized script). This patch corrects this behaviour.

##### Parameters

|Parameters|Description
|--:|---
|args|Arguments to the *info* command

##### Returns

Return value of the *info* command

##### See Also

[ddt::source_debug], [ddt::package_debug]

***
### Proc: ddt::BuildCommandPositionsCmdString

Identifies the command positions in a command's last argument.
*BuildCommandPositionsCmdString* extracts the scripts provided as
last arguments to a commands (ex 'proc', 'foreach' and
'namespace eval' and evaluates the position of the commands contained
inside the script. *BuildCommandPositionsCmdString* calls
*BuildCommandPositions* to get the command positions, after removing
the {} or "" that encloses the scripts.

##### Parameters

|Parameters|Description
|--:|---
|CmdString|Command string that has as last argument a script
|SrcId|Source identifier of the script
|Offset|Position offset, used for the analysis of sub-scripts

##### Returns

\-

##### See Also

[ddt::BuildCommandPositions], [ddt::Instrumentalize]

***
### Proc: ddt::BuildCommandPositions

Identifies the positions of the commands that are present in a script.
These positions are stored inside the array variables *CommandPosListN*
and *CommandPosListRC*.

To identify the command position BuildCommandPositions uses the
outputs from Tcl's ::tcl::unsupported::disassemble command. This output
is stored inside the array variable *DisassembleInfo*.

BuildCommandPositions is recursively called for code sections that
are not byte compiled (e.g. proc, namespace, foreach). The optional
argument *Offset* defines the offset position of the sub script inside
the full script.

##### Parameters

|Parameters|Description
|--:|---
|Script|Script for which the command positions have to be analysed
|SrcId|Source identifier of the script
|[Offset]|Position offset, used for the analysis of sub-scripts

##### Returns

\-

##### See Also

[ddt::BuildCommandPositionsCmdString], [ddt::Instrumentalize]

***
### Proc: ddt::Instrumentalize

Instrumentalizes a file or a script. This command can be used in 2 ways.

* Just a file is provided but not a script: In this case the file

content is read and instrumentalized.

* A file and a script is provided. The provided script is

instrumentalized in this case and the file name is just used as identifier.

##### Parameters

|Parameters|Description
|--:|---
|FileName|File name (can also be a fictitious identifier)
|[Script]|If provided this script will be instrumentalized

##### Returns

File/script source identifier

##### See Also

[GetInstrumentalizedSource]

***
### Proc: ddt::RunEnvironment_Init

Initializes the run environment for the slave program. If an execution
in a slave interpreter is required, this one is created. Then, the
initialization variables are defined and the initialization scripts
executed.
If debugging is required, e.g. if break points are set, the patched
commands (source, package, info) are activated.
If debugging is required and if the execution happens by a slave
interpreter the required set of debug commands are created in the
::ddt namespace of the slave interpreter.

##### Parameters

|Parameters|Description
|--:|---
|[DebugSupport]|Indicates if debugging is required

##### Returns

\-

##### See Also

[ddt::RunEnvironment_Stop], [ddt::RunEnvironment_Resume], [ddt::RunEnvironment_Distroy]

***
### Proc: ddt::RunEnvironment_Stop

Switches the run environment into non-debugging mode

##### Parameters

\-

##### Returns

\-

##### See Also

[ddt::RunEnvironment_Init], [ddt::RunEnvironment_Resume], [ddt::RunEnvironment_Distroy]

***
### Proc: ddt::RunEnvironment_Resume

Resumes the debugging mode of the run environment

##### Parameters

\-

##### Returns

\-

##### See Also

[ddt::RunEnvironment_Init], [ddt::RunEnvironment_Stop], [ddt::RunEnvironment_Distroy]

***
### Proc: ddt::RunEnvironment_Distroy

Destroys the debugging run environment

##### Parameters

\-

##### Returns

\-

##### See Also

[ddt::RunEnvironment_Init], [ddt::RunEnvironment_Stop], [ddt::RunEnvironment_Resume]

***
### Proc: ddt::Brk

This procedure will be inserted in front of each command inside the
debugged source files and scripts. It will need to decide if a
continuously executed program needs to stop due to a breakpoint that
is set or because a program sequence is executed in single step mode.
Brk will call an application specific callback function that allows
inspecting the status of the debugged program or procedure. By calling
the procedure Refresh, Brk will explicitly call this callback function.
By calling the procedure Exec, Brk will execute a command sequence in
the context of the debugged program/procedure.

##### Parameters

|Parameters|Description
|--:|---
|SrcId|Source identifier of the script
|LineNbr|Line where this break command is inserted
|[ColNbr]|Optional column where this break command is inserted. Only defined if not at the first location in the line.

##### Returns

##### See Also

***
### Proc: ddt::Log

Log the information provided as argument. This procedure is
implemented in the ddc namespace of the slave interpreter. It calls
LogDirect that will perform the log inside the main interpreter.

##### Parameters

|Parameters|Description
|--:|---
|args|The list elements are concatenated

##### Returns

\-

##### See Also

[ddt::LogDirect]

***
### Proc: ddt::LogDirect

Logs the information provided as argument in the context of the main
interpreter. LogDirect will be aliased from the main interpreter to
the slave interpreter.

##### Parameters

|Parameters|Description
|--:|---
|args|The list elements are concatenated

##### Returns

\-

##### See Also

[ddt::Log]

[Configuration]: Configuration
[DDT internal variables]: DDT internal variables
[GetInstrumentalizedSource]: GetInstrumentalizedSource
[ddt::BuildCommandPositions]: ddt::BuildCommandPositions
[ddt::BuildCommandPositionsCmdString]: ddt::BuildCommandPositionsCmdString
[ddt::Configure]: ddt::Configure
[ddt::Cont]: ddt::Cont
[ddt::Eval]: ddt::Eval
[ddt::Exec]: ddt::Exec
[ddt::GetBP]: ddt::GetBP
[ddt::GetSource]: ddt::GetSource
[ddt::GetSourceId]: ddt::GetSourceId
[ddt::Instrumentalize]: ddt::Instrumentalize
[ddt::Log]: ddt::Log
[ddt::LogDirect]: ddt::LogDirect
[ddt::Run]: ddt::Run
[ddt::RunEnvironment_Distroy]: ddt::RunEnvironment_Distroy
[ddt::RunEnvironment_Init]: ddt::RunEnvironment_Init
[ddt::RunEnvironment_Resume]: ddt::RunEnvironment_Resume
[ddt::RunEnvironment_Stop]: ddt::RunEnvironment_Stop
[ddt::SetBP]: ddt::SetBP
[ddt::Step]: ddt::Step
[ddt::Stop]: ddt::Stop
[ddt::SwapBP]: ddt::SwapBP
[ddt::info_debug]: ddt::info_debug
[ddt::package_debug]: ddt::package_debug
[ddt::source_debug]: ddt::source_debug
[dt::GetBP]: dt::GetBP
[dt::SetBP]: dt::SetBP
